\documentclass{extarticle}
%% usepackage taken from https://tex.stackexchange.com/a/327136/135365
%%   thanks https://tex.stackexchange.com/users/4427/egreg
\usepackage[
  top=2cm,
  bottom=2cm,
  left=3cm,
  right=2cm,
  headheight=27pt, % as per the warning by fancyhdr
  %includehead,includefoot,
  heightrounded, % to avoid spurious underfull messages
]{geometry} 

\usepackage{xspace}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepackage{color}
\usepackage[subpreambles=true]{standalone}
\usepackage{cancel}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{forest}

\input{reclojure-colors}
\input{reclojure-commands}
\input{reclojure-listings}


\title{DEMO: Recognizing Regular Patterns in Mixed-Type Sequences using Symbolic Finite Automata}
\author{Jim Newton}


\begin{document}
\sloppy
\maketitle

\section{Introduction}

\section{Clojure Multiple-arity Functions}

The Clojure language supports functions of multiple arity.  At the run-time selects which arity of the function to call.

\newsavebox\multarityA
\begin{lrbox}{\multarityA}
  \begin{minipage}{7cm}
    \input{multarityA}
  \end{minipage}
\end{lrbox}

\usebox\multarityA


Multiple-arity function definition also supports destructuring.

\newsavebox\multarityB
\begin{lrbox}{\multarityB}
  \begin{minipage}{7cm}
    \input{multarityB}
  \end{minipage}
\end{lrbox}

\usebox\multarityB

However Clojure does not discriminate on the basis of structure, only on basis
of arity.  The following example contains two definitions for arity 3.

\newsavebox\multarityC
\begin{lrbox}{\multarityC}
  \begin{minipage}{7cm}
    \input{multarityC}
  \end{minipage}
\end{lrbox}

\usebox\multarityC

An attempt to define such a function will result in a compilation error.

\noindent\includegraphics[width=0.8\textwidth]{error-2-arity-overloads.png}

So-called \emph{type hints} may be specified but they have no semantic effect at run-time.
The following type hint \code{Boolean} is ignored if the function is called with a first
argument which is not of type \code{Boolean}.

\newsavebox\multarityD
\begin{lrbox}{\multarityD}
  \begin{minipage}{7cm}
    \input{multarityD}
  \end{minipage}
\end{lrbox}

\usebox\multarityD

Some types are valid, some are not. E.g., \code{Ratio} is not
recognized (rather you must use the verbose name
\code{clojure.lang.Ratio}), and \code{int?} is a type \code{predicate}
not type name.

\newsavebox\multarityE
\begin{lrbox}{\multarityE}
  \begin{minipage}{7cm}
    \input{multarityE}
  \end{minipage}
\end{lrbox}

\usebox\multarityE

The use of invalid type hints usually results in compilation errors.

\noindent\includegraphics[width=0.8\textwidth]{invalid-type-hint-ratio.png}
\noindent\includegraphics[width=0.8\textwidth]{invalid-type-hint-int.png}

However, some invalid type hints are silently ignored and seem to have no
effect on the resulting code.

\newsavebox\multarityF
\begin{lrbox}{\multarityF}
  \begin{minipage}{7cm}
    \input{multarityF}
  \end{minipage}
\end{lrbox}

\usebox\multarityF

\section{Introducting \code{dsdefn} Destructuring Define Function}

The simplest form of \code{dsdefn} allows the programmer to select the
expressions to evaluate based on arity and structure.

\newsavebox\multarityG
\begin{lrbox}{\multarityG}
  \begin{minipage}{7cm}
    \input{multarityG}
  \end{minipage}
\end{lrbox}

\usebox\multarityG

If multiple desturing lambda lists are identical, a warning is issued.
But when called, the function selects the first matching function to evaluate.

\newsavebox\multarityH
\begin{lrbox}{\multarityH}
  \begin{minipage}{7cm}
    \input{multarityH}
  \end{minipage}
\end{lrbox}

\usebox\multarityH

\code{dsdefn} also allows type hints with semantics.  At function call time
the first matter which matches the types of the given argument values is
selected and evaluated.

\newsavebox\multarityI
\begin{lrbox}{\multarityI}
  \begin{minipage}{7cm}
    \input{multarityI}
  \end{minipage}
\end{lrbox}

\usebox\multarityI

Attention the value \code{10} is not of type \code{Integer} in Clojure.  Rather to match
an integer we must use a type predicate:
\code{int?} (to exclude big-nums) or perhaps \code{integer?} (to include big-nums).


\newsavebox\multarityJ
\begin{lrbox}{\multarityJ}
  \begin{minipage}{7cm}
    \input{multarityJ}
  \end{minipage}
\end{lrbox}

\usebox\multarityJ


\noindent\includegraphics[width=0.8\textwidth]{vain-attempt-int.png}

Rather than a raw type predicate we have to use an alternate
syntax. \code{(satisfies int?)}.  Unfortunately, we cannot use
\code{(satisfies int?)} directly in the Clojure type-hint syntax.
Clojure does not allow us to use a non-symbol a as type-hint.


\newsavebox\multarityK
\begin{lrbox}{\multarityK}
  \begin{minipage}{7cm}
    \input{multarityK}
  \end{minipage}
\end{lrbox}

\usebox\multarityK

\noindent\includegraphics[width=0.8\textwidth]{illegal-meta-data.png}

Because of this limitation, we provide an alternative/supplementary syntax.
We may preceed the argument list vector with a hash as meta data.  The
hash associates variable names declared in the argument vector with
type declarations.

\newsavebox\multarityL
\begin{lrbox}{\multarityL}
  \begin{minipage}{7cm}
    \input{multarityL}
  \end{minipage}
\end{lrbox}

\usebox\multarityL

\begin{verbatim}
1. Unhandled clojure.lang.ExceptionInfo
   No pattern matching given sequence
   {:sequence (1 2 [false 20])}
                      REPL:  109  reclojure2025/fn/fn
               RestFn.java:  439  clojure.lang.RestFn/invoke
                      REPL:  119  reclojure2025/eval65437
                      REPL:  119  reclojure2025/eval65437
             Compiler.java: 7700  clojure.lang.Compiler/eval
    interruptible_eval.clj:  106  nrepl.middleware.interruptible-eval/evaluator/run/fn
    interruptible_eval.clj:  101  nrepl.middleware.interruptible-eval/evaluator/run
               session.clj:  230  nrepl.middleware.session/session-exec/session-loop
        SessionThread.java:   21  nrepl.SessionThread/run
\end{verbatim}

In selecting which clause to evaluate, a computation is done using a
Dfa.  The Dfa is build by the macro expansion (when the macro expansion
is evaluated).  When the function \code{f} is called the Dfa is traversed
once to determine which piece of code to evalu

\newsavebox\multarityM
\begin{lrbox}{\multarityM}
  \begin{minipage}{7cm}
    \input{multarityM}
  \end{minipage}
\end{lrbox}

\usebox\multarityM

\noindent\includegraphics[width=\textwidth]{dsdefn.pdf}



\section{The \code{rte-case} Macro}

The \code{rte-case} macro is used like \code{case} except that each
clause is distinguished by an RTE (regular type expression).  The given
sequence 


\end{document}


% LocalWords:  csh clojure clj certifi MacOS clojurin scala scalain bcs repo theg
% LocalWords:  Apprentissage APFON SCALAIN gitlab cri epita ING Scala
% LocalWords:  jim workarea py AssertionError successPercent edn png
% LocalWords:  publishingAt openingAt closingAt maxInFlight limitType
% LocalWords:  tagPrefix handoffType autoPublish yml promo url maas
% LocalWords:  Dockerfile Ingenier activites moulinette testsuite CLI
% LocalWords:  cpus toplevel GitLab ssh config auth html xml cloj ing
% LocalWords:  includegraphics apprentissage adfddde emph textwidth CRI
% LocalWords:  clojurein english maketitle spacelift YAML entrypoint
% LocalWords:  cpu fr gt Eg hacky xyz NotImplementedError ceil int
% LocalWords:  SSH EPITA avatar PyCharm laboratoires
