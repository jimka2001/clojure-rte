;; Copyright (c) 2020,21 EPITA Research and Development Laboratory
;;
;; Permission is hereby granted, free of charge, to any person obtaining
;; a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:
;;
;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.
;;
;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
;; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
;; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
;; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns graph.dot
  (:require [clojure.pprint :refer [cl-format pprint]]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [clojure.set]
            [genus.genus :as gns]
            [rte-construct :refer [rte-to-dfa]]
            [util.cl-compat :as cl]
            [graph.view :as view]
            [xym.xymbolyco :as xym]
            [util.util :refer [member pprint-indent jdefn wrap]]
            [clojure.java.shell :refer [sh]]))

(def ^:dynamic *dot-path*
  "Full path to the graphviz dot program"
  (let [m (sh "which" "dot")]
    (cond
      (= 0 (:exit m)) (str/trim (:out m))
      :else "dot")))

(def ^:dynamic *dot-tmp-dir*
  "Directory to put temporary files"
  (let [m (sh "mktemp" "-d")
        tmp-dir (str (str/trim (:out m)) "/.")]
    (sh "mkdir" "-p" tmp-dir)
    tmp-dir))

(def tmp-files
  "array of tmp files names created by dfa-to-dot and bdd-to-dot"
  (atom []))

(defn delete-tmp-files 
  "Delete the temporary files created by dfa-to-dot and bdd-to-dot."
  []  
  (doseq [fn @tmp-files]
    (when (.exists (io/file fn))
      (io/delete-file fn)))
  (swap! tmp-files (fn [files] (filter (fn [fn] (not (.exists (io/file fn))))
                                       files))))

(jdefn dot-view
    "View the image for the current OS (currently only for Mac OS X).
  The image will be generated by treating the given dot-string
  by the dot executable."
    [dot-string & {:keys [verbose view title dot-file-cb png-file-cb prefix dir]
                   :defaults {:prefix ""
                              :title "no-title"
                              :dir (str "/tmp/" (System/getProperty "user.name"))
                              :verbose false}
                   :as arguments}]
  (let [uuid (random-uuid)
        png-file-name (str dir "/" prefix title "-" uuid ".png")
        dot-file-name (str dir "/" prefix title "-" uuid ".dot")
        ]
    (assert (not= \- (first png-file-name))
            (format "invalid png file name: %s" png-file-name))
    (when verbose
      (println [:title title :view view :verbose verbose
                :arguments arguments]))
    (let [stat (sh *dot-path* "-Tpng" "-o" png-file-name
                   :in dot-string)]
      (when (not= 0 (:exit stat))
        (println [:title title :view view :verbose verbose
                  :arguments arguments])
        (println [:cmd *dot-path* "-Tpng" "-o" png-file-name
                  ])
        (println stat)))
    (when dot-file-cb
      (with-open [wrtr (io/writer dot-file-name)]
        (.write wrtr dot-string))
      (dot-file-cb dot-file-name))
    (when png-file-cb
      (png-file-cb png-file-name))
    (when (= "Mac OS X" (System/getProperty "os.name"))
      (swap! tmp-files conj png-file-name)
      (view/view-image png-file-name))))
  
(defn line-wrap [data right-margin]
  (binding [clojure.pprint/*print-right-margin* right-margin]
    (clojure.string/replace
     (clojure.string/trim-newline (with-out-str
                                    (pprint data *out*)))
     "\n" ; search
     "\\l     " ; replace
     )))

(jdefn dfa-to-dot
  "Create (and possibly display) a graphical image rendering the automaton
  represented by the given dfa.  dfa is a value as returned from function
  rte/compile, or rte-to-dfa.
  For Mac OS, the :view option may be used to display the image
  interactively.
  dfa-to-dot also accepts an rte (as dfa) in which case it will be converted
  to a Dfa using rte-to-dfa.
  Returns a pair [ abbrevs] the new abbrevs map which is necessarily an extension of
  the given `abbrevs` map.  This map can be used by the caller to
  re-call dba-to-dot with a different dfa.  If any transitions of the second
  dfa have the same type label as the first dfa, then the same abbreviation will
  be used.  This makes it much easier for the human to understand the
  dfa drawings being viewed."
  [dfa & {:keys [title prefix view abbrev draw-sink right-margin dir
                state-legend type-legend report-labels dot-file-cb png-file-cb abbrevs]
          :defaults {:title "no-title"
                     :prefix "dfa"
                     :dir (str "/tmp/" (System/getProperty "user.name"))
                     :draw-sink false
                     :abbrev true
                     :abbrevs {}
                     :view false
                     :right-margin 120
                     :state-legend true
                     :type-legend true
                     :report-labels false
                     :dot-file-cb (fn [_file_name] nil)
                     :png-file-cb (fn [_file_name] nil)
                     }
         :as all-optionals}]
  {:pre [((wrap map? 140) abbrevs)]
   :post [((wrap vector? 141) %)]}

  (cond
    view (let [[dot-string new-abbrevs] (dfa-to-dot dfa (assoc all-optionals :view false))]
           (dot-view dot-string all-optionals)
           (assert (map? new-abbrevs) "line 148")
           [dot-string new-abbrevs])
    
    (seq? dfa)
    (dfa-to-dot (rte-to-dfa dfa) all-optionals)

    :otherwise ;; if dfa is of type Dfa then return a string content of the impending .dot file
    (let [sink-states (xym/find-sink-states dfa)
          visible-states (if draw-sink
                           (xym/states-as-seq dfa)
                           (remove (fn [q] (member q sink-states)) (xym/states-as-seq dfa)))
          visible-state-ids (map :index visible-states)
          transition-labels (distinct (for [q visible-states
                                            [label dst-id] (:transitions q)
                                            :when (member dst-id visible-state-ids)]
                                        label))          
          ;; find smallest non-negative integer not in the used list
          new-index (fn [used]
                      (loop [guess 0]
                        (if (member guess used)
                          (recur (inc guess))
                          guess)))

          ;; we already have some abbrevs, we need to merge some new ones in
          abbrevs (merge abbrevs (reduce (fn [acc-map td]
                                           (if (get acc-map td)
                                             acc-map
                                             (assoc acc-map td (new-index (vals acc-map)))))
                                         abbrevs transition-labels))
          _ (assert (map? abbrevs) "failed map? line 178")
          labels (clojure.set/map-invert abbrevs)
          accepting-states (filter :accepting (xym/states-as-seq dfa))
          all-final-function (every? (fn [q] (fn? (xym/exit-value dfa q)))
                                     accepting-states)
          function-table (if all-final-function
                           (into {}
                                 (for [q accepting-states]
                                   [(xym/exit-value dfa q) (format "fn-%d" (:index q))])))
          state-text (fn [q] 
                       (with-out-str
                         (printf "[")
                         (when (:accepting q)
                           (printf "shape=doublecircle,"))
                         (printf "label=\"q%d" (:index q))
                         (when (:description q)
                           (printf "%s" (:description q)))
                         (printf "\"")
                         (printf "]")))
          all-final-true (every? (fn [q] (= true (xym/exit-value dfa q)))
                                 accepting-states)]
      :report-labels false

      (when report-labels
        (printf "+---------------------------------\n")
        (printf "|Transitions labels for %s %s\n" prefix title)
        (printf "+---------------------------------\n")
        (doseq [[td idx] abbrevs]
          (printf "|   t%d= "idx)
          (pprint-indent td :indent "|     "))
        (printf "+---------------------------------\n"))
      
      ;; print here
      (if (not state-legend)
        (for [q visible-states
              :when (boolean (:pattern q))]
          (cl-format true "q~a= ~a"
                     (:index q) (line-wrap (:pattern q) right-margin))
          ))
      (assert (map? abbrevs) "line 212")
      [(with-out-str
         (cl-format *out* "digraph G {~%")
         (when title
           (cl-format *out* "// ~a~%" title))
         (cl-format *out* "  rankdir=LR;~%")
         (cl-format *out* "  fontname=courier;~%")
         (when abbrev
           (cl-format *out* "  label=\"~a\\l\"~%"
                      (str/replace
                       (str/join
                        "" (concat (if type-legend
                                     (mapcat (fn [index]
                                               ;; only if the label actually exists in dfa
                                               (if (member (labels index) transition-labels)
                                                 [(cl-format false "\\lt~a= ~a"
                                                             index (line-wrap (labels index) right-margin))]
                                                 []))
                                             (range (count (keys labels))))
                                     [""])
                                   ["\\l"]
                                   (for [q visible-states
                                         :when (boolean (:pattern q))]
                                     (if state-legend
                                       (cl-format false "\\lq~a= ~a"
                                                  (:index q) (line-wrap (:pattern q) right-margin))
                                       ""))))
                       "\"" "\\\"")))
         (cl-format *out* "  graph [labeljust=l,nojustify=true];~%")
         (cl-format *out* "  node [fontname=Arial, fontsize=25];~%")
         (cl-format *out* "  edge [fontname=Helvetica, fontsize=20];~%")

         
         (doseq [q (xym/states-as-seq dfa)]
           (cl/cl-cond
            ((and (member q sink-states)
                  (not draw-sink)))
            (:else
             (printf "   q%d %s ;\n" (:index q) (state-text q))

             (when (:accepting q)
               ;; if all exit values are explicitly true, the don't draw
               ;; any exit arrows.
               (cond all-final-true
                     nil

                     all-final-function
                     (do (cl-format *out* "   q~D -> X~D ;~%" (:index q) (:index q))
                         (cl-format *out* "   X~D [label=\"~A\", shape=rarrow]~%"
                                    (:index q) (function-table (xym/exit-value dfa q))))

                     :otherwise
                     (do (cl-format *out* "   q~D -> X~D ;~%" (:index q) (:index q))
                         (cl-format *out* "   X~D [label=\"~A\", shape=rarrow]~%" ;; or plaintext ?
                                    (:index q) (xym/exit-value dfa q)))))
             (when (:initial q)
               (cl-format *out* "   H~D [label=\"\", style=invis, width=0]~%" (:index q))
               (cl-format *out* "   H~D -> q~D;~%" (:index q) (:index q)))
             (doseq [[next-state transitions] (group-by second (:transitions q))
                     ;; if there are parallel transitions, print them seperated by comma
                     :let [type-desigs (map first transitions)
                           labels (if abbrev
                                    (for [td type-desigs]
                                      (cl-format false "t~a" (abbrevs td)))
                                    type-desigs)
                           label (str/join "," labels)
                           ;; draw indeterminate transitions as dashed lines
                           inh-text (if (some (fn [td] (gns/inhabited? td false)) type-desigs)
                                      ""
                                      ",style=dashed")
                           ]]
               (cl/cl-cond
                ((and (member (xym/state-by-index dfa next-state) sink-states)
                      (not draw-sink)))
                (:else

                 (cl-format *out* "   q~D -> q~D [label=\"~a\"~a];~%"
                            (:index q) next-state label inh-text)))))))
         
         (cl-format *out* "}~%"))
       abbrevs])))

(jdefn dfa-view 
    "Draw a dfa graphically using `dfa-to-dot` returning a vector [ ... abbrevs]
     abbrevs maps types to abbreviation.
     This map is an extension of the given abbrevs map."
  [dfa title & {:keys [abbrevs draw-sink report-labels dir]
                :defaults {:abbrevs {}
                           :dir (str "/tmp/" (System/getProperty "user.name"))
                           :report-labels true
                           :draw-sink false}
                :as opts}]
  {:post [((wrap vector? 303) %)]}
  (dfa-to-dot dfa opts))

(jdefn bdd-to-dot 
  "Create (and possibly display) a graphical image rendering the given Bdd
  For Mac OS, the :view option may be used to display the image
  interactively."
  [bdd & {:keys [title view pen-width draw-false-leaf]
          :as all-optionals
          :defaults {:title "no-title"
                     :view false
                     :pen-width 2
                     :draw-false-leaf true}}]
  (cond
    view (let [dot-string (bdd-to-dot bdd
                                      :title title
                                      :view false
                                      :pen-width pen-width
                                      :draw-false-leaf draw-false-leaf)]
           (dot-view dot-string all-optionals))
    :else
    (letfn [(draw-connection [direction bdd node-to-index]
              (cond
                (and (not draw-false-leaf)
                     (= (direction bdd) false))
                nil

                (= :positive direction)
                (cl-format *out* "~D -> ~D [style=~A,color=~A,penwidth=~D]~%"
                           (node-to-index bdd) (node-to-index (direction bdd))
                           "solid" "green" pen-width)

                (= :negative direction)
                (cl-format *out* "~D -> ~D [style=~A,color=~A,penwidth=~D,arrowhead=~s,arrowtail=~s,dir=~s]~%"
                           (node-to-index bdd) (node-to-index (direction bdd))
                           "dashed" "red" pen-width "normal" "odot" "both")))
            
            (write-leaf [leaf node-to-index]
              (cond
                (= true leaf)
                (cl-format *out* "~D [shape=~A,label=~S,fontname=~S]~%"
                           (node-to-index leaf)
                           "box"
                           "T"
                           "sans-serif")
                (= false leaf)
                (when draw-false-leaf
                  (cl-format *out* "~D [shape=~A,label=~S]~%"
                             (node-to-index leaf)
                             "box"
                             "&perp;"))))
            
            (top-sort [groups]
              ;; find all the labels which no bdd references,
              ;; these are the independent nodes.
              (loop [labels (set (keys groups))
                     groups groups
                     acc []]
                (if (empty? labels)
                  acc
                  (let [referenced-labels (set (for [[_label seq] groups
                                                     bdd seq
                                                     direction '(:positive :negative)
                                                     :let [child (direction bdd)]
                                                     :when (not (boolean? child))]
                                                 (:label child)))
                        unreferenced-labels (clojure.set/difference labels referenced-labels)
                        ]
                    (recur referenced-labels
                           (apply dissoc groups unreferenced-labels)
                           (concat acc unreferenced-labels))))))]
      (with-out-str
        (cl-format *out* "digraph G {~%")
        (when title
          (cl-format *out* "// ~a~%" title))
        (cl-format *out* "  fontname=courier;~%")
        (let [all-nodes (set (tree-seq (fn [node]
                                         (not (member node '(true false))))
                                       (fn [bdd]
                                         (for [child '(:positive :negative)
                                               :when (or draw-false-leaf
                                                         (child bdd))]
                                           (child bdd)))
                                       bdd))
              node-to-index (zipmap all-nodes (range))
              apex-node (first all-nodes)
              leaf-nodes (clojure.set/intersection #{true false} all-nodes)
              internal-nodes (clojure.set/difference all-nodes leaf-nodes)
              groups (group-by :label internal-nodes)
              sorted-labels (top-sort groups)]


          (if (member apex-node '(true false))
            (write-leaf apex-node node-to-index) ;; always draw the leaf if there's only one, independent of draw-false-leaf
            (do
              (if draw-false-leaf
                (doseq [leaf leaf-nodes]
                  (write-leaf leaf node-to-index))
                (write-leaf true node-to-index))
              (doseq [label sorted-labels]
                (cl-format *out* "{rank=same")
                (doseq [bdd (groups label)]
                  (cl-format *out* " ~D" (node-to-index bdd)))
                (cl-format *out* "}~%")
                (doseq [bdd (groups label)]
                  (cl-format *out* "~D [shape=~A,label=~S,penwidth=~D]~%"
                             (node-to-index bdd)
                             "ellipse"
                             (cl-format false "~A" label)
                             pen-width)
                  (draw-connection :positive bdd node-to-index )
                  (draw-connection :negative bdd node-to-index )))
              
              )))
        (cl-format *out* "}~%")))))
